## 가비지 콜렉터
.NET 프레임워크에서 제공해주는 자동 메모리 관리 기능(
[MS Docs 참고](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/))

## 장점
1. 기존 프로그래밍 언어에서 메모리 할당을 했지만 해제를 잊어버리는 것을 방지.<br>
2. C-런타임(C/C++)에서 링크드 리스트로 관리하는 메모리 블록을 탐색하고, 크기를 재조정하는 데 발생하는 오버헤드 방지.

## 대상
관리형 코드(CLR에 의해 관리되는 코드)<br>
**[비관리형 코드(CLR에 의해 관리되지 않는 코드, unsafe 키워드)는 제외]**

## 작동 원리
1. 메모리 공간에 관리되는 힙 영역을 확보
   
2. 다음 객체를 할당할 주소 포인터 위치시킴
   
3. JIT 컴파일러가 루트의 목록을 만들어 관리<br>
   (루트: 메모리의 위치를 참조하는 객체)

4. 루트 목록을 관리하며 상태를 갱신
   
5. 루트와 관련이 없는 객체가 있다면 해당 메모리 공간을 비움
   
6. 공간이 비어 있는 메모리를 다른 객체를 이동시켜서 정리

## 세대별 가비지 컬렉션
- 0세대: 가비지 컬렉션을 겪지 않아본 갓 생성된 객체
- 1세대: 0, 2세대의 중간 객체
- 2세대: 수 차례 가비지 컬렉션을 겪고도 살아남은 객체

0세대 GC(가비지 컬렉션) 수행 후 살아남은 객체 1세대로<br>
1세대 GC 수행 시 0세대 GC도 진행<br>
1세대 GC 후 살아남은 1세대 객체 -> 2세대로, 살아남은 0세대 객체 -> 1세대로 <br>
2세대 GC 수행 시 1세대 0세대 전체 메모리에 대해 GC 수행(Full GC)<br>
**(이때 애플리케이션 Downtime 발생)**

## 그럼에도 불구하고 효율적인 코드를 위한 지침
- 객체를 많이 할당하지 않기
  
- 너무 큰 객체할당은 피하기<br>
  LOH(대형 객체 힙) 동작 방식은 C-런타임과 유사하므로 GC의 장점 X<br>
  LOH는 2세대 힙으로 간주되어 FUll GC 발생(Downtime)

- 너무 복잡한 참조관계는 피하기
- 루트를 많이 만들지 않기